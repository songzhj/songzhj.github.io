<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>songzhj - js高级程序设计-chapter6</title>
	<link rel="stylesheet" href="../css/style.css">
	<link rel="stylesheet" href="../css/note.css">
	<script type="text/javascript" src="../js/jquery-1.12.1.min.js"></script>
	<script type="text/javascript" src="../js/scrollTop.js"></script>
</head>
<body>
	<div class="header"></div>
	<div class="body">
		<ul id="dd">
			<li>数据属性</li><p>Configurable：表示能否通过delete删除属性从而重新定义属性</p><p>Enumerable：表示能否通过for-in循环返回属性</p><p>Writable：表示能否修改属性的值</p><p>Value：包含这个属性的数据值</p><p>Value属性默认为undefined，其它三个默认为true</p>
			<li>Object.defineProperty()</li><p>可以修改属性默认的特性</p><p>接受三个参数，1.对象 2.属性的名字 3.描述符对象。其中描述符对象拥有上面的四个属性。</p><p>如果调用这个函数但不指定具体属性，属性的默认是为false</p>
			<li>访问器属性</li><p>包含一堆getter和setter函数</p><p>两个函数都不是必须的，非严格模式下，只指定getter意味着属性是不能写的，只指定setter在读取属性的时候会返回undefined</p>
			<li>同时定义多个属性</li><p>Object.defineProperties()：可以同时对一个对象的不同属性进行定义，需要传递两个参数：第一个是需要定义的对象；第二个是包含所有属性和属性的定义的对象</p>
			<li>获取属性的特性</li><p>可以使用Object.getOwnPropertyDescriptor()得到任意对象的某个属性的特性</p>
			<li>创建对象的方法</li><p>工厂模式</p><p>构造函数模式</p><p>原型模式</p><p>动态原型模式</p><p>寄生构造函数模式</p><p>稳妥构造函数模式</p>
			<li>isPrototypeof()</li><p>判断一个对象是否是某个原型的对象</p>
			<li>hasOwnProperty()</li><p>检测一个属性是否存在与一个实例中，，或是存在于原型中</p>
			<li>in操作符</li><p>两种用法，for-in与in</p><p>in可以判断一个对象中是否有某个属性，无论这个属性存在于实例中还是原型中</p><p>可以同时使用in和hasOwnProperty()判断属性到底是存在于对象中，还是原型中</p>
			<li>keys()</li><p>返回一个对象的所有可枚举实例属性（数组形式返回）</p>
			<li>原型的动态性</li><p>原型的任何修改，都会被实例所察觉，无论实例在什么时候创建</p><p>如果直接重写整个原型，则会切断原型与之前创建的实例的联系。（实例中的指针仅指向原型，而不是构造函数。）</p>
			<li>结合使用构造函数模式和原型模式</li><p>使用构造函数定义实例属性，使用原型模式定义方法和共享属性</p>
			<li>动态原型模式</li><p>在构造函数中使用原型模式初始化原型，并用if条件语句对其加以判断</p>
			<li>寄生构造函数模式</li><p>除了使用new操作符并把使用的包装函数叫做构造函数之外，和工厂模式并没区别</p><p>可以在特殊的情况下为对象创建构造函数（创建一个具有额外方法的Array，不能直接修改Array的构造函数，可以使用寄生构造函数）</p>
			<li>继承</li><p>继承主要依靠原型链</p><p>将子类的原型指向超类的一个实例，就可以实现继承</p><p>原型链继承会受到原型中包含引用值类型的困扰，因此在实践中很少单独使用原型链</p>
			<li>借用构造函数方法实现继承</li><p>在子类的构造函数中通过call()或apply()调用超类的构造函数</p><p>可以在子类构造函数中向超类中传递参数，这是原型链做不到的，但缺点是没办法实现函数复用</p>
			<li>组合继承</li><p>将原型链和借用构造函数两种方法的长处结合到一起（P168）</p>
			<li>原型式继承</li><p>只想让一个对象与另一个对象相似，而无需动用构造函数的情况下，原型式继承完全可以胜任</p><p>就像原型模式一样，引用类型的值会共享</p>
			<li>寄生组合式继承</li><p>减少了一个构造函数的调用</p><p>普遍认为寄生组合式继承是引用类型最理想的继承方式</p>
		</ul>
	</div>
	<div class="back">
	</div>
	<div class="toTop"></div>
</body>
</html>